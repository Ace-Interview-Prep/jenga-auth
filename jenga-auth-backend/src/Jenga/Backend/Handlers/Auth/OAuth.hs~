module Jenga.Backend.Handlers.Auth.OAuth where

import Jenga.Backend.DB.Auth
-- import Backend.DB

-- import Backend.Utils.Log
import Jenga.Backend.Utils.Snap
import Jenga.Backend.Utils.HasConfig
import Jenga.Backend.Utils.HasTable
import Jenga.Common.Schema
import Jenga.Common.Auth
import Data.Signed.ClientSession

import Rhyolite.Account
import Obelisk.Route
import Obelisk.OAuth.AccessToken (TokenRequest (..), TokenGrant (..), getOauthToken)
import Obelisk.OAuth.Authorization (OAuth (..), RedirectUriParams (..))
import Database.Beam.Postgres
import Database.Beam.Schema

import Snap
import Snap.Extras.JSON
import qualified Network.HTTP.Client as Http
import qualified Network.HTTP.Types.Header as Http
import Network.HTTP.Client.TLS
import Web.ClientSession as CS
import Data.Pool
import Control.Monad.Trans.Reader
import Control.Monad.IO.Class
import Data.Dependent.Sum
import Data.Maybe (fromMaybe)
import Data.Functor.Identity
import qualified Data.Aeson as Aeson
import qualified Data.Text as T
import qualified Data.Text.Encoding as T

-- TODO: they dont need to reset password if they have signed up with github
-- | TODO: not actually in use, should actually work no problem with github
oauthHandler
  :: forall db beR cfg frontendRoute m.
     ( MonadSnap m
     , Database Postgres db
     , HasConfig cfg (FullRouteEncoder beR frontendRoute)
     , HasConfig cfg (Pool Connection)
     , HasConfig cfg BaseURL
     , HasConfig cfg CS.Key
     , HasConfig cfg OAuthClientSecret
     , HasConfig cfg OAuthClientID
     , HasJengaTable Postgres db Account
     , HasJengaTable Postgres db GithubID
     )
  => DSum OAuth Identity
  -> beR (R OAuth)
  -> R frontendRoute
  -> R frontendRoute
  -> ReaderT cfg m ()
oauthHandler oauthRoute oAuthRedirectGADT redirectToRoute redirectNoAuth = case oauthRoute of
  OAuth_RedirectUri :/ redirectParams -> case redirectParams of
    Nothing -> liftIO $ error "Expected to receive the authorization code here"
    Just (RedirectUriParams code _mstate) -> do
      clientId <- getOAuthClientID <$> asksM -- Cfg _oAuthClientId
      clientSecret <- getOAuthClientSecret <$> asksM -- Cfg _oAuthClientSecret
      route' <- T.pack . show . getBaseURL <$> asksM -- Cfg $ T.pack . show . _baseRoute
      csk <- asksM -- Cfg _clientSessionKey
      let t = TokenRequest
            { _tokenRequest_grant = TokenGrant_AuthorizationCode $ T.encodeUtf8 code
            , _tokenRequest_clientId = clientId
            , _tokenRequest_clientSecret = clientSecret
            , _tokenRequest_redirectUri = (\x -> oAuthRedirectGADT :/ x)
            -- BackendRoute_OAuth
            }
          oAuthUrl = "https://github.com/login/oauth/access_token"
      tlsMgr <- liftIO $ Http.newManager tlsManagerSettings

      (checkedEncoder :: FullRouteEncoder beR frontendRoute) <- asksM

      req <- liftIO $ getOauthToken oAuthUrl route' checkedEncoder t
      rsp <- liftIO $ flip Http.httpLbs tlsMgr (req { Http.requestHeaders = Http.requestHeaders req
                                                      <> [(Http.hAccept, "application/json")] }
                                               )
      -- ^ this response should include the access token and probably a refresh token
      let accessToken = fmap access_token . Aeson.decode . Http.responseBody $ rsp
      case accessToken of
        Nothing -> frontendRedirect @beR redirectNoAuth
        --redirectroute' $ FrontendRoute_Main :/ ()
        Just aToken -> do
          reqUser <- liftIO $ Http.parseRequest "https://api.github.com/user"
          let reqUser' = reqUser { Http.requestHeaders = Http.requestHeaders reqUser <>
                                   [ (Http.hAuthorization, "Bearer " <> (T.encodeUtf8 aToken))
                                   , (Http.hUserAgent, "Ace Interview Prep Haskell Server")
                                   ]
                                 }
          res <- liftIO $ flip Http.httpLbs tlsMgr reqUser'
          let userGithub :: Maybe GitHubUser = Aeson.decode . Http.responseBody $ res
          -- they either exist in the database and are logging in or dont exist in the database and are a new user
          case userGithub of
            Nothing -> error "this is likely a bug or you do not have a github account"
            Just userGH -> do
              (ghTbl :: PgTable Postgres db GithubID) <- asksTableM
              maybeGitID <- withDbEnv $ getGithubUserIfTheyExist ghTbl userGH
              case maybeGitID of
                Nothing -> do -- new user signup
                  -- create account
                  let ghEmail = fromMaybe (_githubUser_login userGH) $ _githubUser_github_email userGH
                  (AccountId accountID') <- do
                    (acctsTbl :: PgTable Postgres db Account) <- asksTableM
                    accountID <- withDbEnv $ newAccount acctsTbl (Email $ T.pack ghEmail) Nothing
                    case accountID of
                      Nothing -> error "Insert new account failed" -- should be impossible
                      Just aid -> do
                        withDbEnv $ insertNewGithubID ghTbl userGH aid
                      -- create linked github id
                      -- login
                        pure aid
                  sKey <- signWithKey csk accountID'
                  writeJSON sKey
                  frontendRedirect @beR redirectToRoute --FrontendRoute_Pages :/ Homepage :/ () --accountID'
                  -- redirect to new user onboarding page
                  pure ()
                Just (GithubID _ _) -> do
                  _ <- error "not actually implemented "
                  -- liftIO $ logNoAuth ghid
                  -- liftIO $ logNoAuth uid
                  pure ()
