module Jenga.Common.HasJengaConfig where

import Data.Time.Clock
import qualified Control.Monad.Fail as Fail
import Data.Aeson
import qualified Data.Text as T
import Data.Functor.Identity
import qualified Data.Map as Map
import qualified Data.ByteString as BS
import Obelisk.Route as ObR
import Control.Monad.IO.Class
import Control.Monad.Trans.Reader
--import Network.Mail.Mime
import Network.URI
import Control.Applicative

class HasConfig a b where
  fromCfg :: a -> b

-- class HasJengaTable dbHost db tbl where
--   tableRef :: PgTable dbHost db tbl
-- type PgTable dbHost db x = DatabaseEntity dbHost db (TableEntity x)
-- asksTableM
--   :: (HasJengaTable dbHost db tbl, Monad m)
--   => ReaderT cfg m (PgTable dbHost db tbl)
-- asksTableM = do
--   pure tableRef
  -- r <- Control.Monad.Trans.Reader.ask
  -- pure $ fromCfg r

asksM
  :: (HasConfig cfg x, Monad m) => ReaderT cfg m x
asksM = do
  r <- Control.Monad.Trans.Reader.ask
  pure $ fromCfg r

-- for type self-documentation
newtype BaseURL = BaseURL { getBaseURL :: URI }
newtype AuthCookieName = AuthCookieName { getAuthCookieName :: T.Text }
newtype StripePlan = StripePlan { getStripePlan :: T.Text }
newtype CompanySignupCode = CompanySignupCode { getCompanySignupCode :: T.Text }
newtype SubscribeHash = SubscribeHash { getSubscribeHash :: T.Text } deriving (Eq, Ord)
newtype OAuthClientID = OAuthClientID { getOAuthClientID :: T.Text } deriving (Eq, Ord)
newtype OAuthClientSecret = OAuthClientSecret { getOAuthClientSecret :: T.Text } deriving (Eq, Ord)
data FreeTrialInfo = FreeTrialInfo
  { getFreeTrialCode :: T.Text
  , getFreeTrialLength :: NominalDiffTime
  } deriving (Eq, Ord)
type FullRouteEncoder be fe = IEncoder (ObR.R (FullRoute be fe)) PageName
type IEncoder a b = Encoder Identity Identity a b


getJsonConfigBase :: FromJSON a => T.Text -> Map.Map T.Text BS.ByteString -> (Maybe (Either String a))
getJsonConfigBase key cfgs = fmap eitherDecodeStrict' $ cfgs Map.!? key

-- | Get and parse a json configuration
getJsonConfig :: (FromJSON a, Fail.MonadFail m) => T.Text -> Map.Map T.Text BS.ByteString -> m a
getJsonConfig k cfgs = case getJsonConfigBase k cfgs of
  Nothing -> Fail.fail $ "getJsonConfig missing key: " <> T.unpack k
  Just (Left err) -> Fail.fail $ "getJsonConfig invalid for key " <> T.unpack k <> " : " <> err
  Just (Right val) -> pure val

-- instance HasConfig ConfigEnv ConnectionPool where
--   fromCfg = _dbPool
-- instance HasConfig ConfigEnv EmailConfig where
--   fromCfg = _emailConfig
-- instance HasConfig ConfigEnv AdminEmail where
--   fromCfg = AdminEmail . _emailSendConfig
-- instance HasConfig ConfigEnv BaseURL where
--   fromCfg = BaseURL . _baseRoute
-- instance HasConfig ConfigEnv DomainOption where
--   fromCfg = _domainName
-- instance HasConfig ConfigEnv StripeConfig where
--   fromCfg = _stripeConfig

renderFullRouteBE
  :: forall be m cfg fe.
     ( Monad m
     , HasConfig cfg (FullRouteEncoder be fe)
     , HasConfig cfg BaseURL
     )
  => ObR.R be
  -> ReaderT cfg m T.Text
renderFullRouteBE route = do
  (enc :: FullRouteEncoder be fe)  <- asksM -- _routeEncoder
  BaseURL baseUrl <- asksM
  pure $ (T.pack $ show baseUrl) <> renderBackendRoute enc route

renderFullRouteFE
  :: forall be m cfg fe.
     ( Monad m
     , HasConfig cfg (FullRouteEncoder be fe)
     , HasConfig cfg BaseURL
     )
  => ObR.R fe
  -> ReaderT cfg m T.Text
renderFullRouteFE route = do
  (enc :: FullRouteEncoder be fe)  <- asksM -- _routeEncoder
  BaseURL baseUrl <- asksM
  pure $ (T.pack $ show baseUrl) <> renderFrontendRoute enc route

isLocalHostEnv
  :: ( MonadIO m
     , HasConfig cfg (BaseURL)
     )
  => ReaderT cfg m Bool
isLocalHostEnv = T.isPrefixOf "http://localhost:" . T.pack . show . getBaseURL <$> asksM

data Plans = Plans
  { defaultPlan :: Maybe StripePlan
  , getPlans :: Map.Map SubscribeHash StripePlan
  }

lookupSubscriptionCodeEnv
  :: ( Monad m
     , HasConfig cfg Plans
     )
  => Maybe T.Text
  -> ReaderT cfg m (Maybe StripePlan)
lookupSubscriptionCodeEnv codeAsked = do
  plans <- asksM -- _subscriptionCodes (baseSubscription, codesMap)
  pure $ (codeAsked >>= flip Map.lookup (getPlans plans) . SubscribeHash) <|> defaultPlan plans

matchesCompanyCodeEnv
  :: ( Monad m
     , HasConfig cfg CompanySignupCode
     )
  => T.Text
  -> ReaderT cfg m Bool
matchesCompanyCodeEnv c = (==c) . getCompanySignupCode <$>  asksM
  -- let
  --   x = do
  --     (codeAsked >>= flip lookup (getPlans plans)) <|> defaultPlans plans
  --     -- withCode codeAsked <|> defaultPlan plans
  --     -- where
  --     --   withCode c = do
  --     --     hash <- c
  --     --     lookup hash (getPlans plans)


  -- pure $ maybe (defaultPlan plans)
  --   ( \code -> Map.findWithDefault (defaultPlan plans) code (getPlans plans)
  --   )
  --   codeAsked


newtype StripeCode = StripeCode T.Text

data DomainOption = ProxiedDomain T.Text T.Text | DirectDomain T.Text
